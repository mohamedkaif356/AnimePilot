package com.seekho.animepilot.presentation.anime_detail

import com.google.common.truth.Truth.assertThat
import com.seekho.animepilot.core.domain.model.AnimeDetail
import com.seekho.animepilot.core.domain.model.AppError
import com.seekho.animepilot.core.domain.model.Result
import com.seekho.animepilot.core.domain.usecase.GetAnimeDetailUseCase
import com.seekho.animepilot.core.util.ConnectivityObserver
import com.seekho.animepilot.core.util.ErrorMapper
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Test
import app.cash.turbine.test
import kotlinx.coroutines.ExperimentalCoroutinesApi

@OptIn(ExperimentalCoroutinesApi::class)
class AnimeDetailViewModelTest {

    private lateinit var getAnimeDetailUseCase: GetAnimeDetailUseCase
    private lateinit var connectivityObserver: ConnectivityObserver
    private lateinit var viewModel: AnimeDetailViewModel

    @Before
    fun setup() {
        getAnimeDetailUseCase = mockk()
        connectivityObserver = mockk(relaxed = true)
        // By default, connectivity observer emits true (online)
        every { connectivityObserver.observeConnectivity() } returns flowOf(true)
    }

    private fun createTestAnimeDetail(id: Int = 1): AnimeDetail {
        return AnimeDetail(
            id = id,
            title = "Test Anime",
            synopsis = "Test synopsis",
            genres = listOf("Action", "Adventure"),
            cast = listOf("Character 1", "Character 2"),
            trailerUrl = "https://youtube.com/watch?v=test123",
            rating = 8.5,
            episodes = 12,
            posterUrl = "https://example.com/poster.jpg"
        )
    }

    @Test
    fun `initial state is Loading`() = runTest {
        // When
        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)

        // Then
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            cancelAndConsumeRemainingEvents()
        }
    }

    @Test
    fun `loadAnimeDetail with valid ID emits Loading then Success`() = runTest {
        // Given
        val animeDetail = createTestAnimeDetail()
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)

        // When
        viewModel.loadAnimeDetail(1)

        // Then
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            val successState = awaitItem()
            assertThat(successState).isInstanceOf(AnimeDetailUiState.Success::class.java)
            assertThat((successState as AnimeDetailUiState.Success).animeDetail).isEqualTo(animeDetail)
            assertThat(successState.isRefreshing).isFalse()
            cancelAndConsumeRemainingEvents()
        }
    }

    @Test
    fun `loadAnimeDetail with same ID and already loaded does not reload`() = runTest {
        // Given
        val animeDetail = createTestAnimeDetail()
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)
        viewModel.loadAnimeDetail(1)

        // Wait for success
        viewModel.uiState.test {
            awaitItem() // Loading
            awaitItem() // Success
            cancelAndIgnoreRemainingEvents()
        }

        // When - load same ID again
        viewModel.loadAnimeDetail(1)

        // Then - should not emit new Loading state
        viewModel.uiState.test {
            val currentState = awaitItem()
            assertThat(currentState).isInstanceOf(AnimeDetailUiState.Success::class.java)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `loadAnimeDetail with error emits Error state`() = runTest {
        // Given
        val error = AppError.NetworkError.NoInternet
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Error(error)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)

        // When
        viewModel.loadAnimeDetail(1)

        // Then
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            val errorState = awaitItem()
            assertThat(errorState).isInstanceOf(AnimeDetailUiState.Error::class.java)
            val errorUiState = errorState as AnimeDetailUiState.Error
            assertThat(errorUiState.error).isEqualTo(error)
            assertThat(errorUiState.canRetry).isTrue()
            assertThat(errorUiState.errorTitle).isEqualTo(ErrorMapper.getErrorTitle(error))
            assertThat(errorUiState.errorMessage).isEqualTo(ErrorMapper.toUserMessage(error))
        }
    }

    @Test
    fun `loadAnimeDetail with exception emits Error state`() = runTest {
        // Given
        val exception = RuntimeException("Test exception")
        every { getAnimeDetailUseCase(1) } returns flow {
            emit(Result.Loading)
            throw exception
        }

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)

        // When
        viewModel.loadAnimeDetail(1)

        // Then
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            val errorState = awaitItem()
            assertThat(errorState).isInstanceOf(AnimeDetailUiState.Error::class.java)
            assertThat((errorState as AnimeDetailUiState.Error).canRetry).isTrue()
        }
    }

    @Test
    fun `refresh triggers reload when already loaded`() = runTest {
        // Given
        val animeDetail = createTestAnimeDetail()
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)
        viewModel.loadAnimeDetail(1)

        // Wait for success
        viewModel.uiState.test {
            awaitItem() // Loading
            awaitItem() // Success
            cancelAndIgnoreRemainingEvents()
        }

        // Setup new flow for refresh
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail.copy(title = "Updated Title"))
        )

        // When
        viewModel.refresh()

        // Then - should emit Loading (with isRefreshing=true) then Success
        viewModel.uiState.test {
            val loadingState = awaitItem()
            assertThat(loadingState).isInstanceOf(AnimeDetailUiState.Success::class.java)
            assertThat((loadingState as AnimeDetailUiState.Success).isRefreshing).isTrue()
            
            val successState = awaitItem()
            assertThat(successState).isInstanceOf(AnimeDetailUiState.Success::class.java)
            assertThat((successState as AnimeDetailUiState.Success).isRefreshing).isFalse()
        }
    }

    @Test
    fun `retry triggers reload`() = runTest {
        // Given
        val error = AppError.NetworkError.NoInternet
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Error(error)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)
        viewModel.loadAnimeDetail(1)

        // Wait for error
        viewModel.uiState.test {
            awaitItem() // Loading
            awaitItem() // Error
            cancelAndIgnoreRemainingEvents()
        }

        // Setup success flow for retry
        val animeDetail = createTestAnimeDetail()
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail)
        )

        // When
        viewModel.retry()

        // Then
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Success::class.java)
        }
    }

    @Test
    fun `error with NoInternet sets isOffline to true when already loaded`() = runTest {
        // Given
        val animeDetail = createTestAnimeDetail()
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)
        viewModel.loadAnimeDetail(1)

        // Wait for success
        viewModel.uiState.test {
            awaitItem()
            awaitItem()
            cancelAndIgnoreRemainingEvents()
        }

        // Setup error flow
        val error = AppError.NetworkError.NoInternet
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Error(error)
        )

        // When
        viewModel.refresh()

        // Then
        viewModel.uiState.test {
            awaitItem() // Refreshing state
            val errorState = awaitItem()
            assertThat(errorState).isInstanceOf(AnimeDetailUiState.Success::class.java)
            assertThat((errorState as AnimeDetailUiState.Success).isRefreshing).isFalse()
        }
    }

    @Test
    fun `error without NoInternet sets isOffline to false when already loaded`() = runTest {
        // Given
        val animeDetail = createTestAnimeDetail()
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Success(animeDetail)
        )

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)
        viewModel.loadAnimeDetail(1)

        // Wait for success
        viewModel.uiState.test {
            awaitItem()
            awaitItem()
            cancelAndIgnoreRemainingEvents()
        }

        // Setup error flow with non-network error
        val error = AppError.DataError.EmptyResponse
        every { getAnimeDetailUseCase(1) } returns flowOf(
            Result.Loading,
            Result.Error(error)
        )

        // When
        viewModel.refresh()

        // Then
        viewModel.uiState.test {
            awaitItem() // Refreshing state
            val errorState = awaitItem()
            assertThat(errorState).isInstanceOf(AnimeDetailUiState.Success::class.java)
        }
    }

    @Test
    fun `refresh with no current anime ID does nothing`() = runTest {
        // Given
        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)

        // When
        viewModel.refresh()

        // Then - should remain in Loading state
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `retry with no current anime ID does nothing`() = runTest {
        // Given
        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)

        // When
        viewModel.retry()

        // Then - should remain in Loading state
        viewModel.uiState.test {
            assertThat(awaitItem()).isInstanceOf(AnimeDetailUiState.Loading::class.java)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `loading state when already in Success sets isRefreshing to true`() = runTest {
        // Given
        val animeDetail = createTestAnimeDetail()
        val successFlow = flowOf<Result<AnimeDetail>>(
            Result.Loading,
            Result.Success(animeDetail)
        )

        every { getAnimeDetailUseCase(1) } returns successFlow

        viewModel = AnimeDetailViewModel(getAnimeDetailUseCase, connectivityObserver)
        viewModel.loadAnimeDetail(1)

        // Wait for success
        viewModel.uiState.test {
            awaitItem() // Loading
            awaitItem() // Success
            cancelAndIgnoreRemainingEvents()
        }

        // Setup flow that emits Loading after Success
        every { getAnimeDetailUseCase(1) } returns flowOf(Result.Loading)

        // When - trigger refresh which will emit Loading
        viewModel.refresh()

        // Then
        viewModel.uiState.test {
            val state = awaitItem()
            assertThat(state).isInstanceOf(AnimeDetailUiState.Success::class.java)
            assertThat((state as AnimeDetailUiState.Success).isRefreshing).isTrue()
        }
    }
}
